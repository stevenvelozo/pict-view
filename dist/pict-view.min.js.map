{"version":3,"sources":["pict-view.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/package.json","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","package.json","source/Pict-View.js"],"names":["f","exports","module","define","amd","window","global","self","this","PictView","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","name","version","description","main","scripts","start","test","tests","coverage","build","mocha","diff","extension","package","reporter","slow","timeout","ui","repository","type","url","keywords","author","license","bugs","homepage","devDependencies","fable","quackage","libPackage","FableServiceProviderBase","constructor","pFable","pOptions","pServiceHash","isFable","connectFable","_PackageFableServiceProvider","UUID","getUUID","options","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","static","CoreServiceProviderBase","types","lint","eslint","pict","typescript","dependencies","libFableServiceBase","defaultPictViewSettings","DefaultRenderable","DefaultDestinationAddress","DefaultTemplateRecordAddress","ViewIdentifier","AutoInitialize","AutoInitializeOrdinal","AutoRender","AutoRenderOrdinal","AutoSolveWithApp","AutoSolveOrdinal","CSSHash","CSS","CSSProvider","CSSPriority","Templates","DefaultTemplates","Renderables","Manifests","super","Object","assign","JSON","parse","stringify","_Package","AppData","initializeTimestamp","lastSolvedTimestamp","lastRenderedTimestamp","lastMarshalFromViewTimestamp","lastMarshalToViewTimestamp","tmpTemplate","Source","TemplateProvider","addTemplate","Template","error","tmpDefaultTemplate","addDefaultTemplate","Prefix","Postfix","tmpCSSHash","tmpCSSProvider","CSSMap","addCSS","renderables","tmpRenderable","addRenderable","pRenderableHash","pTemplateHash","pDefaultTemplateRecordAddress","pDefaultDestinationAddress","pRenderMethod","RenderableHash","TemplateHash","ContentDestinationAddress","RenderMethod","LogNoisiness","trace","onBeforeInitialize","onBeforeInitializeAsync","fCallback","onInitialize","onInitializeAsync","initialize","LogControlFlow","warn","onAfterInitialize","getTimeStamp","initializeAsync","tmpAnticipate","instantiateServiceProviderWithoutRegistration","info","anticipate","bind","onAfterInitializeAsync","wait","pError","message","stack","onBeforeRender","pRenderable","pRenderDestinationAddress","pRecord","onBeforeRenderAsync","buildRenderOptions","pTemplateRecordAddress","tmpRenderOptions","Valid","Renderable","DestinationAddress","RecordAddress","Record","DataProvider","getDataByAddress","undefined","assignRenderContent","pContent","ContentAssignment","projectContent","TestAddress","render","tmpRenderableHash","tmpRecordAddress","tmpRecord","tmpRenderDestinationAddress","tmpContent","parseTemplateByHash","onAfterRender","renderAsync","tmpCallback","Name","newAnticipate","fOnBeforeRenderCallback","fAsyncTemplateCallback","fOnAfterRenderCallback","onAfterRenderAsync","renderDefaultAsync","basicRender","basicRenderAsync","onBeforeSolve","onBeforeSolveAsync","onSolve","onSolveAsync","solve","onAfterSolve","solveAsync","onAfterSolveAsync","onBeforeMarshalFromView","onBeforeMarshalFromViewAsync","onMarshalFromView","onMarshalFromViewAsync","marshalFromView","onAfterMarshalFromView","marshalFromViewAsync","onAfterMarshalFromViewAsync","onBeforeMarshalToView","onBeforeMarshalToViewAsync","onMarshalToView","onMarshalToViewAsync","marshalToView","onAfterMarshalToView","marshalToViewAsync","onAfterMarshalToViewAsync","isPictView"],"mappings":"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","file":"pict-view.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictView = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.15\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"fable\": \"^3.0.143\",\n        \"quackage\": \"^1.0.33\"\n    }\n}\n},{}],2:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Object} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{\"../package.json\":1}],3:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"pict-view\",\n    \"version\": \"1.0.59\",\n    \"description\": \"Pict View Base Class\",\n    \"main\": \"source/Pict-View.js\",\n    \"scripts\": {\n        \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n        \"start\": \"node source/Pict-View.js\",\n        \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t pict-view-image:local\",\n        \"docker-dev-run\": \"docker run -it -d --name pict-view-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/pict-view\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" pict-view-image:local\",\n        \"docker-dev-shell\": \"docker exec -it pict-view-dev /bin/bash\",\n        \"types\": \"tsc -p .\",\n        \"lint\": \"eslint source/**\"\n    },\n    \"types\": \"types/source/Pict-View.d.ts\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"git+https://github.com/stevenvelozo/pict-view.git\"\n    },\n    \"author\": \"steven velozo <steven@velozo.com>\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/pict-view/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/pict-view#readme\",\n    \"devDependencies\": {\n        \"@eslint/js\": \"^9.17.0\",\n        \"browser-env\": \"^3.3.0\",\n        \"eslint\": \"^9.17.0\",\n        \"pict\": \"^1.0.228\",\n        \"quackage\": \"^1.0.36\",\n        \"typescript\": \"^5.7.2\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"dependencies\": {\n        \"fable\": \"^3.0.146\",\n        \"fable-serviceproviderbase\": \"^3.0.15\"\n    }\n}\n\n},{}],4:[function(require,module,exports){\n\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libPackage = require('../package.json');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\t// If this is set to true, when the App initializes this will.\n\t\t// After the App initializes, initialize will be called as soon as it's added.\n\t\tAutoInitialize: true,\n\t\tAutoInitializeOrdinal: 0,\n\n\t\t// If this is set to true, when the App autorenders (on load) this will.\n\t\t// After the App initializes, render will be called as soon as it's added.\n\t\tAutoRender: true,\n\t\tAutoRenderOrdinal: 0,\n\n\t\tAutoSolveWithApp: true,\n\t\tAutoSolveOrdinal: 0,\n\n\t\tCSSHash: false,\n\t\tCSS: false,\n\t\tCSSProvider: false,\n\t\tCSSPriority: 500,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\n/** @typedef {(error?: Error) => void} ErrorCallback */\n/** @typedef {number | boolean} PictTimestamp */\n\n/**\n * @typedef {'replace' | 'append' | 'prepend' | 'append_once'} RenderMethod\n */\n/**\n * @typedef {Object} Renderable\n *\n * @property {string} RenderableHash - A unique hash for the renderable.\n * @property {string} TemplateHash] - The hash of the template to use for rendering this renderable.\n * @property {string} [DefaultTemplateRecordAddress] - The default address for resolving the data record for this renderable.\n * @property {string} [ContentDestinationAddress] - The default address (DOM CSS selector) for rendering the content of this renderable.\n * @property {RenderMethod} [RenderMethod=replace] - The method to use when projecting the renderable to the DOM ('replace', 'append', 'prepend', 'append_once').\n * @property {string} [TestAddress] - The address to use for testing the renderable.\n */\n\n/**\n * Represents a view in the Pict ecosystem.\n */\nclass PictView extends libFableServiceBase\n{\n\t/**\n\t * @param {any} pFable - The Fable object that this service is attached to.\n\t * @param {any} [pOptions] - (optional) The options for this service.\n\t * @param {string} [pServiceHash] - (optional) The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\t//FIXME: add types to fable and ancillaries\n\t\t/** @type {any} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {String} */\n\t\tthis.UUID;\n\t\t/** @type {String} */\n\t\tthis.Hash;\n\t\t/** @type {any} */\n\t\tthis.log;\n\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\t\t// Convenience and consistency naming\n\t\t/** @type {import('pict') & { log: any, instantiateServiceProviderWithoutRegistration: (hash: String) => any }} */\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.pict.AppData;\n\n\t\t/** @type {PictTimestamp} */\n\t\tthis.initializeTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastSolvedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastRenderedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalFromViewTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalToViewTimestamp = false;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!('Hash' in tmpTemplate) || !('Template' in tmpTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!('Postfix' in tmpDefaultTemplate) || !('Template' in tmpDefaultTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load the CSS if it's available\n\t\tif (this.options.CSS)\n\t\t{\n\t\t\tlet tmpCSSHash = this.options.CSSHash ? this.options.CSSHash : `View-${this.options.ViewIdentifier}`;\n\t\t\tlet tmpCSSProvider = this.options.CSSProvider ? this.options.CSSProvider : tmpCSSHash;\n\t\t\tthis.pict.CSSMap.addCSS(tmpCSSHash, this.options.CSS, tmpCSSProvider, this.options.CSSPriority);\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\t/** @type {Object<String, Renderable>} */\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\t/** @type {Renderable} */\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\t\t\tthis.addRenderable(tmpRenderable);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a renderable to the view.\n\t *\n\t * @param {string | Renderable} pRenderableHash - The hash of the renderable, or a renderable object.\n\t * @param {string} [pTemplateHash] - (optional) The hash of the template for the renderable.\n\t * @param {string} [pDefaultTemplateRecordAddress] - (optional) The default data address for the template.\n\t * @param {string} [pDefaultDestinationAddress] - (optional) The default destination address for the renderable.\n\t * @param {RenderMethod} [pRenderMethod=replace] - (optional) The method to use when rendering the renderable (ex. 'replace').\n\t */\n\taddRenderable(pRenderableHash, pTemplateHash, pDefaultTemplateRecordAddress, pDefaultDestinationAddress, pRenderMethod)\n\t{\n\t\t/** @type {Renderable} */\n\t\tlet tmpRenderable;\n\n\t\tif (typeof(pRenderableHash) == 'object')\n\t\t{\n\t\t\t// The developer passed in the renderable as an object.\n\t\t\t// Use theirs instead!\n\t\t\ttmpRenderable = pRenderableHash;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/** @type {RenderMethod} */\n\t\t\tlet tmpRenderMethod = (typeof(pRenderMethod) !== 'string') ? pRenderMethod : 'replace';\n\t\t\ttmpRenderable = (\n\t\t\t\t{\n\t\t\t\t\tRenderableHash: pRenderableHash,\n\t\t\t\t\tTemplateHash: pTemplateHash,\n\t\t\t\t\tDefaultTemplateRecordAddress: pDefaultTemplateRecordAddress,\n\t\t\t\t\tContentDestinationAddress: pDefaultDestinationAddress,\n\t\t\t\t\tRenderMethod: tmpRenderMethod\n\t\t\t\t});\n\t\t}\n\n\t\tif ((typeof(tmpRenderable.RenderableHash) != 'string') || (typeof(tmpRenderable.TemplateHash) != 'string'))\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable; RenderableHash or TemplateHash are invalid.`, tmpRenderable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} adding renderable [${tmpRenderable.RenderableHash}] pointed to template ${tmpRenderable.TemplateHash}.`);\n\t\t\t}\n\n\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                        Code Section: Initialization                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized.\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized.\n\t */\n\tonInitialize()\n\t{\n\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view initialization.\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\tthis.onAfterInitialize();\n\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Performs view initialization (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initializeAsync:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t/** @param {Error} pError */\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization failed: ${pError.message || pError}`, { stack: pError.stack });\n\t\t\t\t\t}\n\t\t\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Render                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered.\n\t *\n\t * @param {Renderable} pRenderable - The renderable that will be rendered.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {any} pRecord - The record (data) that will be used to render the renderable.\n\t */\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pRecord)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Builds the render options for a renderable.\n\t *\n\t * For DRY purposes on the three flavors of render.\n\t *\n\t * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbuildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = {Valid: true};\n\t\ttmpRenderOptions.RenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t\t\t\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ?\n\t\t\t\t\t\t\t\tthis.options.DefaultRenderable : false;\n\t\tif (!tmpRenderOptions.RenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not find a suitable RenderableHash ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.Renderable = this.renderables[tmpRenderOptions.RenderableHash];\n\t\tif (!tmpRenderOptions.Renderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.DestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderOptions.Renderable.ContentDestinationAddress) === 'string') ? tmpRenderOptions.Renderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\t\tif (!tmpRenderOptions.DestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address (param ${pRenderDestinationAddress}).`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = 'Passed in as object';\n\t\t\ttmpRenderOptions.Record = pTemplateRecordAddress;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderOptions.Renderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderOptions.Renderable.DefaultTemplateRecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\t\t\ttmpRenderOptions.Record = (typeof (tmpRenderOptions.RecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRenderOptions.RecordAddress) : undefined;\n\t\t}\n\n\t\treturn tmpRenderOptions;\n\t}\n\n\t/**\n\t * Assigns the content to the destination address.\n\t *\n\t * For DRY purposes on the three flavors of render.\n\t *\n\t * @param {Renderable} pRenderable - The renderable to render.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {string} pContent - The content to render.\n\t * @returns {boolean} - Returns true if the content was assigned successfully.\n\t * @memberof PictView\n\t */\n\tassignRenderContent(pRenderable, pRenderDestinationAddress, pContent)\n\t{\n\t\treturn this.pict.ContentAssignment.projectContent(pRenderable.RenderMethod, pRenderDestinationAddress, pContent, pRenderable.TestAddress);\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string} [pRenderable] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @return {boolean}\n\t */\n\trender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] render:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Render of Renderable[${tmpRenderableHash}] to Destination [${tmpRenderDestinationAddress}]...`);\n\t\t}\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord, null, [this]);\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${tmpContent.length} to Destination [${tmpRenderDestinationAddress}] using render method [${tmpRenderable.RenderMethod}].`);\n\t\t}\n\n\t\t// Assign the content to the destination address\n\t\tthis.pict.ContentAssignment.projectContent(tmpRenderable.RenderMethod, tmpRenderDestinationAddress, tmpContent, tmpRenderable.TestAddress);\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\n\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t *\n\t * @return {void}\n\t */\n\trenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address.`);\n\t\t\treturn tmpCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] renderAsync:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Asynchronous Render (callback-style)...`);\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.newAnticipate();\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnBeforeRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\t\t\t\tthis.onBeforeRenderAsync(fOnBeforeRenderCallback);\n\t\t\t});\n\n\t\tlet tmpContent;\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fAsyncTemplateCallback) =>\n\t\t\t{\n\t\t\t\t// Render the template (asynchronously)\n\t\t\t\tthis.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord,\n\t\t\t\t\t(pError, pContent) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderableHash}) because it did not parse the template.`, pError);\n\t\t\t\t\t\t\treturn fAsyncTemplateCallback(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpContent = pContent;\n\n\t\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${pContent.length} to Destination [${tmpRenderDestinationAddress}] using Async render method ${tmpRenderable.RenderMethod}.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.pict.ContentAssignment.projectContent(tmpRenderable.RenderMethod, tmpRenderDestinationAddress, pContent, tmpRenderable.TestAddress);\n\n\t\t\t\t\t\t// Execute the developer-overridable asynchronous post-render behavior\n\t\t\t\t\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\t\treturn fAsyncTemplateCallback();\n\t\t\t\t\t}, [this]);\n\t\t\t});\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnAfterRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\t\t\t\tthis.onAfterRenderAsync(fOnAfterRenderCallback);\n\t\t\t});\n\n\t\ttmpAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * Renders the default renderable.\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\trenderDefaultAsync(fCallback)\n\t{\n\t\t// Render the default renderable\n\t\tthis.renderAsync(fCallback);\n\t}\n\n\t/**\n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbasicRender(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record, null, [this]));\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t */\n\tbasicRenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tconst tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tconst tmpRenderOptions = this.buildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record,\n\t\t\t\t(pError, pContent) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderOptions.RenderableHash} because it did not parse the template.`, pError);\n\t\t\t\t\t\treturn tmpCallback(pError);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, pContent);\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t}, [this]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`;\n\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\treturn tmpCallback(tmpErrorMessage);\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered.\n\t *\n\t * @param {Renderable} pRenderable - The renderable that was rendered.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable was rendered.\n\t * @param {any} pRecord - The record (data) that was used by the renderable.\n\t * @param {string} pContent - The content that was rendered.\n\t */\n\tonAfterRender(pRenderable, pRenderDestinationAddress, pRecord, pContent)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Solver                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is solved.\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved.\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks.\n\t *\n\t * @return {boolean} - True if the view was solved successfully, false otherwise.\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved.\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal From View                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tonBeforeMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view.\n\t */\n\tonMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalFromViewAsync(fCallback)\n\t{\n\n\t\tthis.onMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalFromView();\n\t\tthis.onMarshalFromView();\n\t\tthis.onAfterMarshalFromView();\n\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalFromViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalFromViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view.\n\t */\n\tonAfterMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal To View                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view.\n\t */\n\tonBeforeMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view.\n\t */\n\tonMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data into the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalToView();\n\t\tthis.onMarshalToView();\n\t\tthis.onAfterMarshalToView();\n\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalToViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalToViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view.\n\t */\n\tonAfterMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/** @return {boolean} - True if the object is a PictView. */\n\tget isPictView()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictView;\n\n},{\"../package.json\":3,\"fable-serviceproviderbase\":2}]},{},[4])(4)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.15\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"fable\": \"^3.0.143\",\n        \"quackage\": \"^1.0.33\"\n    }\n}","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Object} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","module.exports={\n    \"name\": \"pict-view\",\n    \"version\": \"1.0.59\",\n    \"description\": \"Pict View Base Class\",\n    \"main\": \"source/Pict-View.js\",\n    \"scripts\": {\n        \"test\": \"./node_modules/.bin/mocha -u tdd -R spec\",\n        \"start\": \"node source/Pict-View.js\",\n        \"coverage\": \"./node_modules/.bin/nyc --reporter=lcov --reporter=text-lcov ./node_modules/mocha/bin/_mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t pict-view-image:local\",\n        \"docker-dev-run\": \"docker run -it -d --name pict-view-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/pict-view\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" pict-view-image:local\",\n        \"docker-dev-shell\": \"docker exec -it pict-view-dev /bin/bash\",\n        \"types\": \"tsc -p .\",\n        \"lint\": \"eslint source/**\"\n    },\n    \"types\": \"types/source/Pict-View.d.ts\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"git+https://github.com/stevenvelozo/pict-view.git\"\n    },\n    \"author\": \"steven velozo <steven@velozo.com>\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/pict-view/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/pict-view#readme\",\n    \"devDependencies\": {\n        \"@eslint/js\": \"^9.17.0\",\n        \"browser-env\": \"^3.3.0\",\n        \"eslint\": \"^9.17.0\",\n        \"pict\": \"^1.0.228\",\n        \"quackage\": \"^1.0.36\",\n        \"typescript\": \"^5.7.2\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"dependencies\": {\n        \"fable\": \"^3.0.146\",\n        \"fable-serviceproviderbase\": \"^3.0.15\"\n    }\n}\n","\nconst libFableServiceBase = require('fable-serviceproviderbase');\n\nconst libPackage = require('../package.json');\n\nconst defaultPictViewSettings = (\n\t{\n\t\tDefaultRenderable: false,\n\t\tDefaultDestinationAddress: false,\n\t\tDefaultTemplateRecordAddress: false,\n\n\t\tViewIdentifier: false,\n\n\t\t// If this is set to true, when the App initializes this will.\n\t\t// After the App initializes, initialize will be called as soon as it's added.\n\t\tAutoInitialize: true,\n\t\tAutoInitializeOrdinal: 0,\n\n\t\t// If this is set to true, when the App autorenders (on load) this will.\n\t\t// After the App initializes, render will be called as soon as it's added.\n\t\tAutoRender: true,\n\t\tAutoRenderOrdinal: 0,\n\n\t\tAutoSolveWithApp: true,\n\t\tAutoSolveOrdinal: 0,\n\n\t\tCSSHash: false,\n\t\tCSS: false,\n\t\tCSSProvider: false,\n\t\tCSSPriority: 500,\n\n\t\tTemplates: [],\n\n\t\tDefaultTemplates: [],\n\n\t\tRenderables: [],\n\n\t\tManifests: {}\n\t});\n\n/** @typedef {(error?: Error) => void} ErrorCallback */\n/** @typedef {number | boolean} PictTimestamp */\n\n/**\n * @typedef {'replace' | 'append' | 'prepend' | 'append_once'} RenderMethod\n */\n/**\n * @typedef {Object} Renderable\n *\n * @property {string} RenderableHash - A unique hash for the renderable.\n * @property {string} TemplateHash] - The hash of the template to use for rendering this renderable.\n * @property {string} [DefaultTemplateRecordAddress] - The default address for resolving the data record for this renderable.\n * @property {string} [ContentDestinationAddress] - The default address (DOM CSS selector) for rendering the content of this renderable.\n * @property {RenderMethod} [RenderMethod=replace] - The method to use when projecting the renderable to the DOM ('replace', 'append', 'prepend', 'append_once').\n * @property {string} [TestAddress] - The address to use for testing the renderable.\n */\n\n/**\n * Represents a view in the Pict ecosystem.\n */\nclass PictView extends libFableServiceBase\n{\n\t/**\n\t * @param {any} pFable - The Fable object that this service is attached to.\n\t * @param {any} [pOptions] - (optional) The options for this service.\n\t * @param {string} [pServiceHash] - (optional) The hash of the service.\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Intersect default options, parent constructor, service information\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictViewSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\t//FIXME: add types to fable and ancillaries\n\t\t/** @type {any} */\n\t\tthis.fable;\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {String} */\n\t\tthis.UUID;\n\t\t/** @type {String} */\n\t\tthis.Hash;\n\t\t/** @type {any} */\n\t\tthis.log;\n\n\t\tif (!this.options.ViewIdentifier)\n\t\t{\n\t\t\tthis.options.ViewIdentifier = `AutoViewID-${this.fable.getUUID()}`;\n\t\t}\n\t\tthis.serviceType = 'PictView';\n\t\t/** @type {Object} */\n\t\tthis._Package = libPackage;\n\t\t// Convenience and consistency naming\n\t\t/** @type {import('pict') & { log: any, instantiateServiceProviderWithoutRegistration: (hash: String) => any }} */\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict application state\n\t\tthis.AppData = this.pict.AppData;\n\n\t\t/** @type {PictTimestamp} */\n\t\tthis.initializeTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastSolvedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastRenderedTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalFromViewTimestamp = false;\n\t\t/** @type {PictTimestamp} */\n\t\tthis.lastMarshalToViewTimestamp = false;\n\n\t\t// Load all templates from the array in the options\n\t\t// Templates are in the form of {Hash:'Some-Template-Hash',Template:'Template content',Source:'TemplateSource'}\n\t\tfor (let i = 0; i < this.options.Templates.length; i++)\n\t\t{\n\t\t\tlet tmpTemplate = this.options.Templates[i];\n\n\t\t\tif (!('Hash' in tmpTemplate) || !('Template' in tmpTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Template ${i} in the options array.`, tmpTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addTemplate(tmpTemplate.Hash, tmpTemplate.Template, tmpTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load all default templates from the array in the options\n\t\t// Templates are in the form of {Prefix:'',Postfix:'-List-Row',Template:'Template content',Source:'TemplateSourceString'}\n\t\tfor (let i = 0; i < this.options.DefaultTemplates.length; i++)\n\t\t{\n\t\t\tlet tmpDefaultTemplate = this.options.DefaultTemplates[i];\n\n\t\t\tif (!('Postfix' in tmpDefaultTemplate) || !('Template' in tmpDefaultTemplate))\n\t\t\t{\n\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Default Template ${i} in the options array.`, tmpDefaultTemplate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tmpDefaultTemplate.Source)\n\t\t\t\t{\n\t\t\t\t\ttmpDefaultTemplate.Source = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} options object.`;\n\t\t\t\t}\n\t\t\t\tthis.pict.TemplateProvider.addDefaultTemplate(tmpDefaultTemplate.Prefix, tmpDefaultTemplate.Postfix, tmpDefaultTemplate.Template, tmpDefaultTemplate.Source);\n\t\t\t}\n\t\t}\n\n\t\t// Load the CSS if it's available\n\t\tif (this.options.CSS)\n\t\t{\n\t\t\tlet tmpCSSHash = this.options.CSSHash ? this.options.CSSHash : `View-${this.options.ViewIdentifier}`;\n\t\t\tlet tmpCSSProvider = this.options.CSSProvider ? this.options.CSSProvider : tmpCSSHash;\n\t\t\tthis.pict.CSSMap.addCSS(tmpCSSHash, this.options.CSS, tmpCSSProvider, this.options.CSSPriority);\n\t\t}\n\n\t\t// Load all renderables\n\t\t// Renderables are launchable renderable instructions with templates\n\t\t// They look as such: {Identifier:'ContentEntry', TemplateHash:'Content-Entry-Section-Main', ContentDestinationAddress:'#ContentSection', RecordAddress:'AppData.Content.DefaultText', ManifestTransformation:'ManyfestHash', ManifestDestinationAddress:'AppData.Content.DataToTransformContent'}\n\t\t// The only parts that are necessary are Identifier and Template\n\t\t// A developer can then do render('ContentEntry') and it just kinda works.  Or they can override the ContentDestinationAddress\n\t\t/** @type {Object<String, Renderable>} */\n\t\tthis.renderables = {};\n\t\tfor (let i = 0; i < this.options.Renderables.length; i++)\n\t\t{\n\t\t\t/** @type {Renderable} */\n\t\t\tlet tmpRenderable = this.options.Renderables[i];\n\t\t\tthis.addRenderable(tmpRenderable);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a renderable to the view.\n\t *\n\t * @param {string | Renderable} pRenderableHash - The hash of the renderable, or a renderable object.\n\t * @param {string} [pTemplateHash] - (optional) The hash of the template for the renderable.\n\t * @param {string} [pDefaultTemplateRecordAddress] - (optional) The default data address for the template.\n\t * @param {string} [pDefaultDestinationAddress] - (optional) The default destination address for the renderable.\n\t * @param {RenderMethod} [pRenderMethod=replace] - (optional) The method to use when rendering the renderable (ex. 'replace').\n\t */\n\taddRenderable(pRenderableHash, pTemplateHash, pDefaultTemplateRecordAddress, pDefaultDestinationAddress, pRenderMethod)\n\t{\n\t\t/** @type {Renderable} */\n\t\tlet tmpRenderable;\n\n\t\tif (typeof(pRenderableHash) == 'object')\n\t\t{\n\t\t\t// The developer passed in the renderable as an object.\n\t\t\t// Use theirs instead!\n\t\t\ttmpRenderable = pRenderableHash;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/** @type {RenderMethod} */\n\t\t\tlet tmpRenderMethod = (typeof(pRenderMethod) !== 'string') ? pRenderMethod : 'replace';\n\t\t\ttmpRenderable = (\n\t\t\t\t{\n\t\t\t\t\tRenderableHash: pRenderableHash,\n\t\t\t\t\tTemplateHash: pTemplateHash,\n\t\t\t\t\tDefaultTemplateRecordAddress: pDefaultTemplateRecordAddress,\n\t\t\t\t\tContentDestinationAddress: pDefaultDestinationAddress,\n\t\t\t\t\tRenderMethod: tmpRenderMethod\n\t\t\t\t});\n\t\t}\n\n\t\tif ((typeof(tmpRenderable.RenderableHash) != 'string') || (typeof(tmpRenderable.TemplateHash) != 'string'))\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not load Renderable; RenderableHash or TemplateHash are invalid.`, tmpRenderable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} adding renderable [${tmpRenderable.RenderableHash}] pointed to template ${tmpRenderable.TemplateHash}.`);\n\t\t\t}\n\n\t\t\tthis.renderables[tmpRenderable.RenderableHash] = tmpRenderable;\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                        Code Section: Initialization                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized.\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized.\n\t */\n\tonInitialize()\n\t{\n\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view initialization.\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\tthis.onAfterInitialize();\n\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Performs view initialization (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initializeAsync:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t{\n\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t/** @param {Error} pError */\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization failed: ${pError.message || pError}`, { stack: pError.stack });\n\t\t\t\t\t}\n\t\t\t\t\tthis.initializeTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.info(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is initialized (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Render                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered.\n\t *\n\t * @param {Renderable} pRenderable - The renderable that will be rendered.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {any} pRecord - The record (data) that will be used to render the renderable.\n\t */\n\tonBeforeRender(pRenderable, pRenderDestinationAddress, pRecord)\n\t{\n\t\t// Overload this to mess with stuff before the content gets generated from the template\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Builds the render options for a renderable.\n\t *\n\t * For DRY purposes on the three flavors of render.\n\t *\n\t * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbuildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = {Valid: true};\n\t\ttmpRenderOptions.RenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t\t\t\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ?\n\t\t\t\t\t\t\t\tthis.options.DefaultRenderable : false;\n\t\tif (!tmpRenderOptions.RenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not find a suitable RenderableHash ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.Renderable = this.renderables[tmpRenderOptions.RenderableHash];\n\t\tif (!tmpRenderOptions.Renderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\ttmpRenderOptions.DestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderOptions.Renderable.ContentDestinationAddress) === 'string') ? tmpRenderOptions.Renderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\t\tif (!tmpRenderOptions.DestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderOptions.RenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address (param ${pRenderDestinationAddress}).`);\n\t\t\ttmpRenderOptions.Valid = false;\n\t\t}\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = 'Passed in as object';\n\t\t\ttmpRenderOptions.Record = pTemplateRecordAddress;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRenderOptions.RecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderOptions.Renderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderOptions.Renderable.DefaultTemplateRecordAddress :\n\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\t\t\ttmpRenderOptions.Record = (typeof (tmpRenderOptions.RecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRenderOptions.RecordAddress) : undefined;\n\t\t}\n\n\t\treturn tmpRenderOptions;\n\t}\n\n\t/**\n\t * Assigns the content to the destination address.\n\t *\n\t * For DRY purposes on the three flavors of render.\n\t *\n\t * @param {Renderable} pRenderable - The renderable to render.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable will be rendered.\n\t * @param {string} pContent - The content to render.\n\t * @returns {boolean} - Returns true if the content was assigned successfully.\n\t * @memberof PictView\n\t */\n\tassignRenderContent(pRenderable, pRenderDestinationAddress, pContent)\n\t{\n\t\treturn this.pict.ContentAssignment.projectContent(pRenderable.RenderMethod, pRenderDestinationAddress, pContent, pRenderable.TestAddress);\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string} [pRenderable] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @return {boolean}\n\t */\n\trender(pRenderable, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderable) === 'string') ? pRenderable :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it is not a valid renderable.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not exist.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderable}) because it does not have a valid destination address.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\t// Execute the developer-overridable pre-render behavior\n\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] render:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Render of Renderable[${tmpRenderableHash}] to Destination [${tmpRenderDestinationAddress}]...`);\n\t\t}\n\t\t// Generate the content output from the template and data\n\t\tlet tmpContent = this.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord, null, [this]);\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${tmpContent.length} to Destination [${tmpRenderDestinationAddress}] using render method [${tmpRenderable.RenderMethod}].`);\n\t\t}\n\n\t\t// Assign the content to the destination address\n\t\tthis.pict.ContentAssignment.projectContent(tmpRenderable.RenderMethod, tmpRenderDestinationAddress, tmpContent, tmpRenderable.TestAddress);\n\n\t\t// Execute the developer-overridable post-render behavior\n\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\n\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Render a renderable from this view.\n\t *\n\t * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t *\n\t * @return {void}\n\t */\n\trenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\tlet tmpRenderableHash = (typeof (pRenderableHash) === 'string') ? pRenderableHash :\n\t\t\t(typeof (this.options.DefaultRenderable) == 'string') ? this.options.DefaultRenderable : false;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!tmpRenderableHash)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not asynchronously render ${tmpRenderableHash} (param ${pRenderableHash}because it is not a valid renderable.`));\n\t\t}\n\n\t\tlet tmpRenderable = this.renderables[tmpRenderableHash];\n\n\t\tif (!tmpRenderable)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`);\n\t\t\treturn tmpCallback(Error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not exist.`));\n\t\t}\n\n\t\tlet tmpRenderDestinationAddress = (typeof (pRenderDestinationAddress) === 'string') ? pRenderDestinationAddress :\n\t\t\t(typeof (tmpRenderable.ContentDestinationAddress) === 'string') ? tmpRenderable.ContentDestinationAddress :\n\t\t\t\t(typeof (this.options.DefaultDestinationAddress) === 'string') ? this.options.DefaultDestinationAddress : false;\n\n\t\tif (!tmpRenderDestinationAddress)\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render ${tmpRenderableHash} (param ${pRenderableHash}) because it does not have a valid destination address.`);\n\t\t\treturn tmpCallback(Error(`Could not render ${tmpRenderableHash}`));\n\t\t}\n\n\t\tlet tmpRecordAddress;\n\t\tlet tmpRecord;\n\n\t\tif (typeof(pTemplateRecordAddress) === 'object')\n\t\t{\n\t\t\ttmpRecord = pTemplateRecordAddress;\n\t\t\ttmpRecordAddress = 'Passed in as object';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpRecordAddress = (typeof (pTemplateRecordAddress) === 'string') ? pTemplateRecordAddress :\n\t\t\t\t(typeof (tmpRenderable.DefaultTemplateRecordAddress) === 'string') ? tmpRenderable.DefaultTemplateRecordAddress :\n\t\t\t\t\t(typeof (this.options.DefaultTemplateRecordAddress) === 'string') ? this.options.DefaultTemplateRecordAddress : false;\n\n\t\t\ttmpRecord = (typeof (tmpRecordAddress) === 'string') ? this.pict.DataProvider.getDataByAddress(tmpRecordAddress) : undefined;\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow VIEW [${this.UUID}]::[${this.Hash}] Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateRecordAddress[${tmpRecordAddress}] renderAsync:`);\n\t\t}\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Beginning Asynchronous Render (callback-style)...`);\n\t\t}\n\n\t\tlet tmpAnticipate = this.fable.newAnticipate();\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnBeforeRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onBeforeRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord);\n\t\t\t\tthis.onBeforeRenderAsync(fOnBeforeRenderCallback);\n\t\t\t});\n\n\t\tlet tmpContent;\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fAsyncTemplateCallback) =>\n\t\t\t{\n\t\t\t\t// Render the template (asynchronously)\n\t\t\t\tthis.pict.parseTemplateByHash(tmpRenderable.TemplateHash, tmpRecord,\n\t\t\t\t\t(pError, pContent) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderableHash} (param ${pRenderableHash}) because it did not parse the template.`, pError);\n\t\t\t\t\t\t\treturn fAsyncTemplateCallback(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpContent = pContent;\n\n\t\t\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} Assigning Renderable[${tmpRenderableHash}] content length ${pContent.length} to Destination [${tmpRenderDestinationAddress}] using Async render method ${tmpRenderable.RenderMethod}.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.pict.ContentAssignment.projectContent(tmpRenderable.RenderMethod, tmpRenderDestinationAddress, pContent, tmpRenderable.TestAddress);\n\n\t\t\t\t\t\t// Execute the developer-overridable asynchronous post-render behavior\n\t\t\t\t\t\tthis.lastRenderedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\t\t\treturn fAsyncTemplateCallback();\n\t\t\t\t\t}, [this]);\n\t\t\t});\n\n\t\ttmpAnticipate.anticipate(\n\t\t\t(fOnAfterRenderCallback) =>\n\t\t\t{\n\t\t\t\tthis.onAfterRender(tmpRenderable, tmpRenderDestinationAddress, tmpRecord, tmpContent);\n\t\t\t\tthis.onAfterRenderAsync(fOnAfterRenderCallback);\n\t\t\t});\n\n\t\ttmpAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * Renders the default renderable.\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\trenderDefaultAsync(fCallback)\n\t{\n\t\t// Render the default renderable\n\t\tthis.renderAsync(fCallback);\n\t}\n\n\t/**\n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t */\n\tbasicRender(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress)\n\t{\n\t\tlet tmpRenderOptions = this.buildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, this.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record, null, [this]));\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string|ErrorCallback} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string|ErrorCallback} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string|object|ErrorCallback} [pTemplateRecordAddress] - The address of (or actual obejct) where the data for the template is stored.\n\t * @param {ErrorCallback} [fCallback] - The callback to call when the async operation is complete.\n\t */\n\tbasicRenderAsync(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress, fCallback)\n\t{\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tconst tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateRecordAddress) === 'function') ? pTemplateRecordAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\tfalse;\n\n\t\tconst tmpRenderOptions = this.buildRenderOptions(pRenderableHash, pRenderDestinationAddress, pTemplateRecordAddress);\n\t\tif (tmpRenderOptions.Valid)\n\t\t{\n\t\t\tthis.pict.parseTemplateByHash(tmpRenderOptions.Renderable.TemplateHash, tmpRenderOptions.Record,\n\t\t\t\t(pError, pContent) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not render (asynchronously) ${tmpRenderOptions.RenderableHash} because it did not parse the template.`, pError);\n\t\t\t\t\t\treturn tmpCallback(pError);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.assignRenderContent(tmpRenderOptions.Renderable, tmpRenderOptions.DestinationAddress, pContent);\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t}, [this]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} could not perform a basic render of ${tmpRenderOptions.RenderableHash} because it is not valid.`;\n\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\treturn tmpCallback(tmpErrorMessage);\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered.\n\t *\n\t * @param {Renderable} pRenderable - The renderable that was rendered.\n\t * @param {string} pRenderDestinationAddress - The address where the renderable was rendered.\n\t * @param {any} pRecord - The record (data) that was used by the renderable.\n\t * @param {string} pContent - The content that was rendered.\n\t */\n\tonAfterRender(pRenderable, pRenderDestinationAddress, pRecord, pContent)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is rendered (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                            Code Section: Solver                            */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before the view is solved.\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved.\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks.\n\t *\n\t * @return {boolean} - True if the view was solved successfully, false otherwise.\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Performs view solving and triggers lifecycle hooks (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved.\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after the view is solved (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal From View                        */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tonBeforeMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view.\n\t */\n\tonMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalFromViewAsync(fCallback)\n\t{\n\n\t\tthis.onMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data from the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalFromView();\n\t\tthis.onMarshalFromView();\n\t\tthis.onAfterMarshalFromView();\n\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalFromViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalFromViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view.\n\t */\n\tonAfterMarshalFromView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalFromView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled from the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalFromViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromView();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal To View                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view.\n\t */\n\tonBeforeMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onBeforeMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers before data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonBeforeMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view.\n\t */\n\tonMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers when data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * Marshals data into the view.\n\t *\n\t * @return {boolean} - True if the operation was successful, false otherwise.\n\t */\n\tmarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} executing solve() function...`);\n\t\t}\n\t\tthis.onBeforeMarshalToView();\n\t\tthis.onMarshalToView();\n\t\tthis.onAfterMarshalToView();\n\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Marshals data into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tmarshalToViewAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.pict.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} marshalToViewAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewTimestamp = this.pict.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view.\n\t */\n\tonAfterMarshalToView()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictView [${this.UUID}]::[${this.Hash}] ${this.options.ViewIdentifier} onAfterMarshalToView:`);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Lifecycle hook that triggers after data is marshaled into the view (async flow).\n\t *\n\t * @param {ErrorCallback} fCallback - The callback to call when the async operation is complete.\n\t */\n\tonAfterMarshalToViewAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToView();\n\t\treturn fCallback();\n\t}\n\n\t/** @return {boolean} - True if the object is a PictView. */\n\tget isPictView()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictView;\n"]}